"use strict";(self.webpackChunkshopify_theme=self.webpackChunkshopify_theme||[]).push([[502],{"96294add2d9632ee5da8":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{StructError:()=>StructError,array:()=>array,assign:()=>assign,boolean:()=>boolean,coerce:()=>coerce,create:()=>create,defaulted:()=>defaulted,instance:()=>instance,integer:()=>integer,is:()=>is,literal:()=>literal,min:()=>min,nullable:()=>nullable,number:()=>number,object:()=>object,optional:()=>optional,record:()=>record,size:()=>size,string:()=>string,tuple:()=>tuple,type:()=>type,union:()=>union,unknown:()=>unknown});class StructError extends TypeError{constructor(failure,failures){let cached;const{message,explanation,...rest}=failure,{path}=failure,msg=path.length===0?message:`At path: ${path.join(".")} -- ${message}`;super(explanation??msg),explanation!=null&&(this.cause=msg),Object.assign(this,rest),this.name=this.constructor.name,this.failures=()=>cached??(cached=[failure,...failures()])}}function isObject(x){return typeof x=="object"&&x!=null}function isPlainObject(x){if(Object.prototype.toString.call(x)!=="[object Object]")return!1;const prototype=Object.getPrototypeOf(x);return prototype===null||prototype===Object.prototype}function print(value){return typeof value=="symbol"?value.toString():typeof value=="string"?JSON.stringify(value):`${value}`}function toFailure(result,context,struct2,value){if(result===!0)return;result===!1?result={}:typeof result=="string"&&(result={message:result});const{path,branch}=context,{type:type2}=struct2,{refinement,message=`Expected a value of type \`${type2}\`${refinement?` with refinement \`${refinement}\``:""}, but received: \`${print(value)}\``}=result;return{value,type:type2,refinement,key:path[path.length-1],path,branch,...result,message}}function*toFailures(result,context,struct2,value){(function(x){return isObject(x)&&typeof x[Symbol.iterator]=="function"})(result)||(result=[result]);for(const r of result){const failure=toFailure(r,context,struct2,value);failure&&(yield failure)}}function*run(value,struct2,options={}){const{path=[],branch=[value],coerce:coerce2=!1,mask:mask2=!1}=options,ctx={path,branch};if(coerce2&&(value=struct2.coercer(value,ctx),mask2&&struct2.type!=="type"&&isObject(struct2.schema)&&isObject(value)&&!Array.isArray(value)))for(const key in value)struct2.schema[key]===void 0&&delete value[key];let status="valid";for(const failure of struct2.validator(value,ctx))failure.explanation=options.message,status="not_valid",yield[failure,void 0];for(let[k,v,s]of struct2.entries(value,ctx)){const ts=run(v,s,{path:k===void 0?path:[...path,k],branch:k===void 0?branch:[...branch,v],coerce:coerce2,mask:mask2,message:options.message});for(const t of ts)t[0]?(status=t[0].refinement!=null?"not_refined":"not_valid",yield[t[0],void 0]):coerce2&&(v=t[1],k===void 0?value=v:value instanceof Map?value.set(k,v):value instanceof Set?value.add(v):isObject(value)&&(v!==void 0||k in value)&&(value[k]=v))}if(status!=="not_valid")for(const failure of struct2.refiner(value,ctx))failure.explanation=options.message,status="not_refined",yield[failure,void 0];status==="valid"&&(yield[void 0,value])}class Struct{constructor(props){const{type:type2,schema,validator,refiner,coercer=value=>value,entries=function*(){}}=props;this.type=type2,this.schema=schema,this.entries=entries,this.coercer=coercer,this.validator=validator?(value,context)=>toFailures(validator(value,context),context,this,value):()=>[],this.refiner=refiner?(value,context)=>toFailures(refiner(value,context),context,this,value):()=>[]}assert(value,message){return function(value2,struct2,message2){const result=validate(value2,struct2,{message:message2});if(result[0])throw result[0]}(value,this,message)}create(value,message){return create(value,this,message)}is(value){return is(value,this)}mask(value,message){return function(value2,struct2,message2){const result=validate(value2,struct2,{coerce:!0,mask:!0,message:message2});if(result[0])throw result[0];return result[1]}(value,this,message)}validate(value,options={}){return validate(value,this,options)}}function create(value,struct2,message){const result=validate(value,struct2,{coerce:!0,message});if(result[0])throw result[0];return result[1]}function is(value,struct2){return!validate(value,struct2)[0]}function validate(value,struct2,options={}){const tuples=run(value,struct2,options),tuple2=function(input){const{done,value:value2}=input.next();return done?void 0:value2}(tuples);return tuple2[0]?[new StructError(tuple2[0],function*(){for(const t of tuples)t[0]&&(yield t[0])}),void 0]:[void 0,tuple2[1]]}function assign(...Structs){const isType=Structs[0].type==="type",schemas=Structs.map(s=>s.schema),schema=Object.assign({},...schemas);return isType?type(schema):object(schema)}function define(name,validator){return new Struct({type:name,schema:null,validator})}function array(Element){return new Struct({type:"array",schema:Element,*entries(value){if(Element&&Array.isArray(value))for(const[i,v]of value.entries())yield[i,v,Element]},coercer:value=>Array.isArray(value)?value.slice():value,validator:value=>Array.isArray(value)||`Expected an array value, but received: ${print(value)}`})}function boolean(){return define("boolean",value=>typeof value=="boolean")}function instance(Class){return define("instance",value=>value instanceof Class||`Expected a \`${Class.name}\` instance, but received: ${print(value)}`)}function integer(){return define("integer",value=>typeof value=="number"&&!isNaN(value)&&Number.isInteger(value)||`Expected an integer, but received: ${print(value)}`)}function literal(constant){const description=print(constant),t=typeof constant;return new Struct({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?constant:null,validator:value=>value===constant||`Expected the literal \`${description}\`, but received: ${print(value)}`})}function never(){return define("never",()=>!1)}function nullable(struct2){return new Struct({...struct2,validator:(value,ctx)=>value===null||struct2.validator(value,ctx),refiner:(value,ctx)=>value===null||struct2.refiner(value,ctx)})}function number(){return define("number",value=>typeof value=="number"&&!isNaN(value)||`Expected a number, but received: ${print(value)}`)}function object(schema){const knowns=schema?Object.keys(schema):[],Never=never();return new Struct({type:"object",schema:schema||null,*entries(value){if(schema&&isObject(value)){const unknowns=new Set(Object.keys(value));for(const key of knowns)unknowns.delete(key),yield[key,value[key],schema[key]];for(const key of unknowns)yield[key,value[key],Never]}},validator:value=>isObject(value)||`Expected an object, but received: ${print(value)}`,coercer:value=>isObject(value)?{...value}:value})}function optional(struct2){return new Struct({...struct2,validator:(value,ctx)=>value===void 0||struct2.validator(value,ctx),refiner:(value,ctx)=>value===void 0||struct2.refiner(value,ctx)})}function record(Key,Value){return new Struct({type:"record",schema:null,*entries(value){if(isObject(value))for(const k in value){const v=value[k];yield[k,k,Key],yield[k,v,Value]}},validator:value=>isObject(value)||`Expected an object, but received: ${print(value)}`})}function string(){return define("string",value=>typeof value=="string"||`Expected a string, but received: ${print(value)}`)}function tuple(Structs){const Never=never();return new Struct({type:"tuple",schema:null,*entries(value){if(Array.isArray(value)){const length=Math.max(Structs.length,value.length);for(let i=0;i<length;i++)yield[i,value[i],Structs[i]||Never]}},validator:value=>Array.isArray(value)||`Expected an array, but received: ${print(value)}`})}function type(schema){const keys=Object.keys(schema);return new Struct({type:"type",schema,*entries(value){if(isObject(value))for(const k of keys)yield[k,value[k],schema[k]]},validator:value=>isObject(value)||`Expected an object, but received: ${print(value)}`,coercer:value=>isObject(value)?{...value}:value})}function union(Structs){const description=Structs.map(s=>s.type).join(" | ");return new Struct({type:"union",schema:null,coercer(value){for(const S of Structs){const[error,coerced]=S.validate(value,{coerce:!0});if(!error)return coerced}return value},validator(value,ctx){const failures=[];for(const S of Structs){const[...tuples]=run(value,S,ctx),[first]=tuples;if(!first[0])return[];for(const[failure]of tuples)failure&&failures.push(failure)}return[`Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,...failures]}})}function unknown(){return define("unknown",()=>!0)}function coerce(struct2,condition,coercer){return new Struct({...struct2,coercer:(value,ctx)=>is(value,condition)?struct2.coercer(coercer(value,ctx),ctx):struct2.coercer(value,ctx)})}function defaulted(struct2,fallback,options={}){return coerce(struct2,unknown(),x=>{const f=typeof fallback=="function"?fallback():fallback;if(x===void 0)return f;if(!options.strict&&isPlainObject(x)&&isPlainObject(f)){const ret={...x};let changed=!1;for(const key in f)ret[key]===void 0&&(ret[key]=f[key],changed=!0);if(changed)return ret}return x})}function min(struct2,threshold,options={}){const{exclusive}=options;return refine(struct2,"min",value=>exclusive?value>threshold:value>=threshold||`Expected a ${struct2.type} greater than ${exclusive?"":"or equal to "}${threshold} but received \`${value}\``)}function size(struct2,min2,max2=min2){const expected=`Expected a ${struct2.type}`,of=min2===max2?`of \`${min2}\``:`between \`${min2}\` and \`${max2}\``;return refine(struct2,"size",value=>{if(typeof value=="number"||value instanceof Date)return min2<=value&&value<=max2||`${expected} ${of} but received \`${value}\``;if(value instanceof Map||value instanceof Set){const{size:size2}=value;return min2<=size2&&size2<=max2||`${expected} with a size ${of} but received one with a size of \`${size2}\``}{const{length}=value;return min2<=length&&length<=max2||`${expected} with a length ${of} but received one with a length of \`${length}\``}})}function refine(struct2,name,refiner){return new Struct({...struct2,*refiner(value,ctx){yield*struct2.refiner(value,ctx);const failures=toFailures(refiner(value,ctx),ctx,struct2,value);for(const failure of failures)yield{...failure,refinement:name}}})}}}]);
//# sourceMappingURL=/cdn/shop/t/1074/assets/shared-superstruct.js.map?v=104635401792922158651761066871
